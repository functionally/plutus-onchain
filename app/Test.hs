-----------------------------------------------------------------------------
--
-- Module      :  $Headers
-- Copyright   :  (c) 2021 Brian W Bush
-- License     :  MIT
--
-- Maintainer  :  Brian W Bush <code@functionally.io>
-- Stability   :  Experimental
-- Portability :  Portable
--
-- | Testing.
--
-----------------------------------------------------------------------------


{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE NoImplicitPrelude     #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}

{-# OPTIONS_GHC -fno-warn-orphans #-}


module Main (
-- * Entry points
  main
) where


import PlutusTx.Prelude

import Codec.Serialise      (serialise)
import Ledger               (Address, ScriptContext(..), Validator, scriptAddress)
import Ledger.Typed.Scripts (DatumType, RedeemerType, TypedValidator, ValidatorTypes, mkTypedValidator, validatorScript, wrapValidator)
import Plutus.OnChain.Random (makeRandomGenerator, nextInteger64)
import PlutusTx              (compile)

import qualified Data.ByteString.Lazy   as LBS
import qualified Prelude                as H
import qualified System.Random.SplitMix as R


-- | A Plutus script for testing.
data TestScript

instance ValidatorTypes TestScript where
  type instance DatumType    TestScript = Integer
  type instance RedeemerType TestScript = Integer


{-# INLINABLE makeTestValidator #-}

-- | A validator for checking that the correct random number is generated by a seed.
makeTestValidator :: Integer
                  -> Integer
                  -> ScriptContext
                  -> Bool
makeTestValidator seed answer _ = 
  let
    generator = makeRandomGenerator seed
    (random, _) = nextInteger64 generator
  in
    random == answer


-- | The test script.
testScript :: TypedValidator TestScript
testScript =
  mkTypedValidator @TestScript
    $$(compile [|| makeTestValidator ||])
      $$(compile [|| wrap ||])
    where
      wrap = wrapValidator @Integer @Integer


-- | The test validator instance.
testValidator :: Validator
testValidator = validatorScript testScript


-- | The address of the test validator instance.
testAddress :: Address
testAddress = scriptAddress testValidator


-- | The serialization of the test script.
testSerialized :: LBS.ByteString
testSerialized = serialise testValidator


-- | Perform simple tests.
main :: H.IO ()
main =
  do

    -- See if the script compiles.
    H.putStrLn ""
    H.putStrLn $ "Successfully compiled Plutus script:"
    H.putStrLn $ "  Address: " ++ H.show testAddress
    H.putStrLn $ "  Length in bytes: " ++ H.show (LBS.length testSerialized)

    -- Test one random number.
    H.putStrLn ""
    H.putStrLn "Validator passes simple test?"
    H.putStrLn $ "  " ++ H.show (makeTestValidator 12345 3576825416751071313 H.undefined)

    -- Test many random numbers.
    let
      test seed =
        let
          generator = R.seedSMGen (H.fromIntegral seed) 0x9e3779b97f4a7c15
          answer = H.fromIntegral . fst $ R.nextWord64 generator
        in
          makeTestValidator seed answer H.undefined
    H.putStrLn ""
    H.putStrLn $ "Validator passes test for first million seeds?"
    H.putStrLn $ "  " ++ H.show (all test [1..1000000])
